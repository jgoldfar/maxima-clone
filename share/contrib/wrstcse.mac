/* %wc_tols lists all tol[n] contained in the list, nested list 
or equation it gets as its argument. */

%wc_tols(wc_x):=block([vars,retval:[]],
    /* A list of all variables contained in wc_x */
    vars:listofvars(wc_x),
    for i in vars do 
        if not(freeof('tol,i)) then
            push(i,retval),
    return(retval)
);

/* %wc_tolrenumber renumbers all tol[n] contained in wc_x to start
with n=startnum */

%wc_tolrenumber(wc_x,startnum):=block(
    [
        oldtols:%wc_tols(wc_x)
    ],
    startnum:startnum-1,
    psubst(
        makelist(
            i=tol[startnum:startnum+1],
            i,
            oldtols
        ),
        wc_x
    )
    
);

/* wc_tolappend appends a list of element values to another renumbering all tol[] found in both lists
so they won't conflict. */

wc_tolappend([wc_args]):=block([wc_retval:[],wc_numberoftols:1],
    for wc_i in wc_args do
    (
        wc_retval:append(wc_retval,%wc_tolrenumber(wc_i,wc_numberoftols)),
        wc_numberoftols:wc_numberoftols+length(%wc_tols(wc_i))
    ),
    wc_retval
);

/* wc_systematic returns a list of the results of all combinations one can get by assigning every tol[n] wc_valuespertol 
values between -1 and 1. */

wc_systematic(wc_x,[wc_valuespertol]):=block(
    [
        %wc_tols:%wc_tols(wc_x),
        /* The index x of the tol[x] being currently assigned a value to */
        wc_tolnum,
        wc_numoftols
    ],
    wc_numoftols:length(%wc_tols),
    
    /* Default the number of values per tolerance parameter to 3 */
    if wc_valuespertol=[] then wc_valuespertol:wc_defaultvaluespertol else wc_valuespertol:first(wc_valuespertol),
    makelist(
        (
            subst(
                (
                    wc_tolnum:-1,
                    makelist(
                        (
                            wc_tolnum:wc_tolnum+1,
                            wc_tol=((floor(mod(wc_num/(wc_valuespertol^wc_tolnum),wc_valuespertol)))/
                                (wc_valuespertol-1)*2-1)
                        ),
                        wc_tol,%wc_tols
                    )
                ),
                wc_x
            )
        ),
        wc_num,0,wc_valuespertol^wc_numoftols-1
    )    
    
);

wc_montecarlo(wc_x,wc_samples):=block(
    [
        %wc_tols:%wc_tols(wc_x),
        wc_numoftols
    ],
    wc_numoftols:length(%wc_tols),
    
    makelist(
        (
            subst(
                makelist(
                    (
                        wc_tol=random(2.0)-1
                    ),
                    wc_tol,%wc_tols
                ),
                wc_x
            )
        ),
        wc_num,1,wc_samples
    )    
    
);

/* Calculates the typical values of wc_x */

wc_typicalvalues(wc_x):=
    subst(
        makelist(i=0,i,%wc_tols(wc_x)),
        wc_x
    );

/* Convenience function: Get the minimum, the typical and the maximal value */

wc_mintypmax(wc_x,[wc_params]):=block([wc_allvalues,wc_param1,min,wc_typ,max],
    if length(wc_params) < 1 then
        wc_param1:wc_defaultvaluespertol
    else
        wc_param1:inpart(wc_params,1),
    
    if wc_param1 > 0 then
        wc_allvalues:wc_systematic(wc_x,wc_param1)
    else
    (
        wc_allvalues:wc_montecarlo(wc_x,-wc_param1)    
    ),
    min:apply('min,wc_allvalues),
    wc_typ:wc_typicalvalues(wc_x),
    max:apply('max,wc_allvalues),
        ['min=min,'typ=wc_typ,'max=max]
);
/* Make this function map over equations */
 ?putprop('mintypmax, ?cdr([?mlist,?mequal]), '?distribute_over)$

/* A function that pretty-prints the value ranges the input values are in */
wc_inputvalueranges(wc_x):=apply('matrix,
    makelist(
        append([lhs(wc_i)],wc_mintypmax(rhs(wc_i))),
        wc_i,wc_x
    )
);

/* A function that creates assumptions on the range the input values are in */
wc_inputvalueassumptions(wc_x):=block([wc_line,wc_assumptions:[]],
    for wc_i in wc_x do
        (
            wc_line:wc_mintypmax(rhs(wc_i)),
            push(lhs(wc_i)<=subst(wc_line,'max),wc_assumptions),
            push(lhs(wc_i)>=subst(wc_line,'min),wc_assumptions)
        ),
    apply('assume,wc_assumptions)
);

/* A function that generates an equation out of the min, typ and maximum value for an element */
wc_mintypmax2tol(wc_tol,wc_min,wc_typ,wc_max):=block([wc_try,wc_dff],
    if wc_min>wc_typ then warning("wc_mintypmax2tol: Min value bigger than typ value"),
    if wc_typ>wc_max then warning("wc_mintypmax2tol: Max value smaller than typ value"),
    /* Try to find a quadratic equation that hits all three points */
    wc_try:((-2*wc_typ+wc_min+wc_max)*wc_tol^2)/2-((wc_min-wc_max)*wc_tol)/2+wc_typ,wc_tol,
    /* Let's see if the quadratic equation overswings the targets */
    wc_dff:diff(wc_try,wc_tol),
    if (subst (wc_tol=-1,wc_dff)<0)  or (subst (wc_tol=0,wc_dff)<0) or (subst (wc_tol=1,wc_dff)<0) then
        wc_try:
            wc_typ+
            (wc_tol+abs(wc_tol))/2*(wc_max-wc_typ)+
            (wc_tol-abs(wc_tol))/2*(wc_typ-wc_min),
    return(wc_try)
);

/* How many sigmas the range of tol[x]=-1...1 is assumed to be wide */
wc_defaultsigma:6;
/* How many samples per tol we want the EWC method to use by default */
wc_defaultvaluespertol:3;
defstruct(wc_rssparams(sigma,mu));

/* Determines the rss parameters of the tolerance of x */
wc_getrssparams(x):=block([tols:[],derivates_linearized,sigmaval,meanval],
    /* Compile a list of tolerances */
    for i in listofvars(x) do
        if not(freeof('tol,i)) then
            push(i,tols),
    /* Create the mean value */
    meanval:wc_typicalvalues(x),
    /* Create a list of derivatives, linearized over the point that all tol[x] are 0.*/
    derivates_linearized:wc_typicalvalues(makelist(taytorat(taylor(diff(x,i),i,0,0)),i,tols)),
    /* Compile the RMS value assuming that all input tolerances were 6-sigma ones*/
    sigmaval:sqrt(lsum(i^2,i,derivates_linearized/wc_defaultsigma)),
    return(new(wc_rssparams(sigmaval,meanval)))
);

/* Determines the rss parameters from the distribution of data */
wc_distrib2rssparams(data):=block([wc_mu,wc_sigma,wc_len],
    if not listp(data) then error("wc_distrib2rssparams: Input data needs to be a list of sample values"),
    wc_len:length(data),
    if wc_len<2 then error("wc_distrib2rssparams: Input data needs to be at least 2 samples long"),
    wc_mu:lsum(i,i,data)/wc_len,
    wc_sigma:lsum((i-wc_mu)^2,i,data)/(wc_len-1),
    return(new(wc_rssparams(wc_sigma,wc_mu)))
);

/* Generates input data for the tolerance parameters from measurement data */
wc_distrib2toldata(tol,data,[sigmas]):=block(
    [wc_rssparams:wc_distrib2rssparams(data),wc_sigmas:wc_defaultsigma],
    if length(sigmas) > 1 then error("wc_distrib2toldata: More than 3 parameters)"),
    if length(sigmas) = 1 then 
    (
        if not numberp(sigmas[1]) then error("wc_distrib2toldata: sigmas needs to be a number)"),
        wc_sigmas:sigmas[1]
    ),
    wc_rssparams@sigma*wc_sigmas*tol+wc_rssparams@mu
);

/* Estimate the tolerances of x assuming that all input value tolerances and the
output tolerances are rss curves. */
wc_mintypmax_rss(x,sigmas):=float(block([rssparams:wc_getrssparams(x)],
    [
        'min=rssparams@mu-sigmas*rssparams@sigma,
        'typ=rssparams@mu,
        'max=rssparams@mu+sigmas*rssparams@sigma,
        Fail=float(1-(erf(sigmas/sqrt(2))))*1e6*"ppm"
    ]
));

/* Like wc_mintypmax_rss, but output the tolerances in percent, not in abs values. */
wc_mintypmax_rss_percent(x,sigmas):=block([rssparams:wc_getrssparams(x)],
    [
        'min=((rssparams@mu-sigmas*rssparams@sigma)/rssparams@mu-1)*100*"%",
        'typ=wc_typicalvalues(x),
        'max=((rssparams@mu+sigmas*rssparams@sigma)/rssparams@mu-1)*100*"%",
        Fail=float(1-(erf(sigmas/sqrt(2))))*1e6*"ppm"
    ]
);

/* Like wc_mintypmax, but output the tolerances in percent, not in abs values. */
wc_mintypmax_percent([x]):=block([mintypmax:apply('wc_mintypmax,x)],
    [
        'min=(subst(mintypmax,'min)/subst(mintypmax,'typ)-1)*100*"%",
        'typ=subst(mintypmax,'typ),
        'max=(subst(mintypmax,'max)/subst(mintypmax,'typ)-1)*100*"%"
    ]
);

/* Finding the extreme Worst Case is O(n^2) complete and therefore slow
for a high number of tol[n]. This function now merges all tol[n] we can
determine for in which direction they will affect the tolerances,
starting at the typical case and merge them in order to speed up the
brute-force step */
wc_ewc_simplify(x):=block(
    [
        /* The derivate of x to the tol[n] we currently look at */
        wc_diffofwctol,
        /*the tol[n] we merge as many tolerances as we can to */
        mergedtol:[],
        /* Is the tol[n] we merge as many tolerances as we can to positive? */
        wc_mergedtoldirection:1
    ],
    for wc_tol in %wc_tols(x) do
    (
        /* Let's see if increasing the current tol[n] increases x*/
        wc_diffofwctol:wc_typicalvalues(diff(x,wc_tol)),
        if wc_diffofwctol > 0 then
            (
                /* increasing tol[n] increases x */
                if mergedtol = [] then
                    (
                        /* merge this tol[n] with all future ones */
                        mergedtol:wc_tol,
                        wc_mergedtoldirection:1
                    )
                else
                    x:subst(wc_tol=wc_mergedtoldirection*mergedtol,x)
            ) else
            (        
                /* The above if might have resulted in true or unknown */
                if wc_diffofwctol < 0 then
                    (
                        /* increasing wc_tol decreases x */
                        if mergedtol = [] then
                            (
                                /* merge this wc_tol with all future ones */
                                mergedtol:wc_tol,
                                wc_mergedtoldirection:-1
                            )
                        else
                                /* merge this wc_tol with the first  one we identified a direction for */
                            x:subst(wc_tol=-wc_mergedtoldirection*mergedtol,x)
                    )
                )
    ),
    return(x)
);

wc_sensitivities(expr):=block([tols:[],wc_result:[]],
    /* Compile a list of tol[n] */
    for i in listofvars(expr) do
        if not(freeof('tol,i)) then
            push(i,tols),
    /* Compile a matrix that shows the sensitivity of expr to this parameter */
    for i in tols do
        push([i,wc_typicalvalues(diff(expr,i))],wc_result),
    return(apply('matrix,wc_result))
);


