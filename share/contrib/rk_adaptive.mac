/* Todo: We could sometimes recycle values of deriv_1step or deriv_2steps */
rk_adaptive(expr,vars,vars_initval,var,startval,endval,[params]):=block(
    [
        result,
        point,
        deriv_1step,
        deriv_2steps,
        time:startval,
        timestep:float((endval-startval)/1000),
        err,
        maxabserr:1e-4,
        maxrelerr:1e-6,
        maxstep:(endval-startval)/100,
        minstep:(endval-startval)/1000000,
        sgn,
        currtimestep,
        minstepwarn:false
    ],
    /* Interpret the optional parameters */
    for i in params do
    (
        if lhs(i)='maxstep then maxstep:rhs(i) else
        if lhs(i)='minstep then minstep:rhs(i) else
        if lhs(i)='timestep_initial then timestep:rhs(i) else
        if lhs(i)='maxabserr then maxabserr:rhs(i) else
        if lhs(i)='maxrelerr then maxrelerr:rhs(i) else
        warning("rk_adaptive: Found a unknown param")
    ),
    if maxrelerr <= 0 then error("rk_adaptive: Illegal value for maxrelerr"),
    if maxabserr <= 0 then error("rk_adaptive: Illegal value for maxabserr"),
    if maxstep <= 0 then error("rk_adaptive: Illegal value for maxstep"),
    if minstep <= 0 then error("rk_adaptive: Illegal value for minstep"),
    if timestep_initial = 0 then error("rk_adaptive: Illegal value for timestep_initial"),
    /* Do we need to reverse some comparisons since the time we end is before the time we start at? */
    if endval >= startval then sgn:1 else sgn:-1,
    /* Make sure our first 3 arguments are lists */
    if not listp(expr) then expr:[expr],
    if not listp(vars) then vars:[vars],
    if not listp(vars_initval) then vars_initval:[vars_initval],

    /* Add the starting point to the result */
    point:vars_initval,
    result:[append([startval],vars_initval)],

    /* Now calculate the other points */
    do (
        do (
            /* Calculate the next 2 points */
            deriv_1step:sgn*subst(var=time,
                subst(map("=",vars,point),expr)
            ),
            deriv_2steps:sgn*subst(var=time+timestep,
                subst(map("=",vars,point+deriv_1step*timestep),expr)
            ),
            /* Calculate the error. Err=1 is the limit */
            err:apply('max,
                map(
                    lambda(
                        [pnt,drv_1step,drv_2steps],
                        if cabs(pnt) > maxrelerr then
                           min(
                               cabs(drv_1step-drv_2steps)/maxabserr,
                               cabs((drv_1step-drv_2steps)/pnt)/maxrelerr
                           )
                        else
                            cabs(drv_1step-drv_2steps)/maxabserr
                    ),
                    point,deriv_1step,deriv_2steps
                )
            ),
            /* Save the time deriv_1step is at */
            currtimestep:timestep,
            /* See if we should adjust the time step width */
            if err>1.0 then
                timestep:sgn*max(sgn*timestep/2,sgn*minstep)
            else if err<.25 then
                timestep:sgn*min(maxstep*sgn,timestep*2),

            /* See if we are happy with the results for this point*/
            if timestep=minstep then
            (
                minstepwarn:true,
                return()
            ),
            if err<=1 then return()
        ),
        time:time+currtimestep,
        push(append([time],point+deriv_1step*currtimestep),result),
        point:point+deriv_1step*timestep,
        if sgn*time>sgn*endval then return()
    ),
    if minstepwarn = true then warning("rk_adaptive: Didn't meet the tolerance goal."),
    /* Convert the result into a more user-friendly format (tm)*/
    args(transpose(apply('matrix,reverse(result))))
);