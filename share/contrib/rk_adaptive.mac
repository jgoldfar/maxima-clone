/* Todo: We could sometimes recycle values of offset_1step or offset_2steps */
rk_adaptive(expr,vars,vars_initval,var,startval,endval,[params]):=block(
    [
        result,
        point,
        offset_1step,
        offset_2steps,
        time:startval,
        timestep:float((endval-startval)/1000),
        err,
        maxabserr:1e-6,
        maxrelerr:1e-6,
        maxstep:(endval-startval)/100,
        minstep:(endval-startval)/1000000,
        sgn,
        nexttime,
        minstepwarn:false
    ],
    /* Interpret the optional parameters */
    for i in params do
    (
        if lhs(i)='maxstep then maxstep:rhs(i) else
        if lhs(i)='minstep then minstep:rhs(i) else
        if lhs(i)='timestep_initial then timestep:rhs(i) else
        if lhs(i)='maxabserr then maxabserr:rhs(i) else
        if lhs(i)='maxrelerr then maxrelerr:rhs(i) else
        warning("rk_adaptive: Found a unknown param")
    ),
    if maxrelerr <= 0 then error("rk_adaptive: Illegal value for maxrelerr"),
    if maxabserr <= 0 then error("rk_adaptive: Illegal value for maxabserr"),
    if maxstep <= 0 then error("rk_adaptive: Illegal value for maxstep"),
    if minstep <= 0 then error("rk_adaptive: Illegal value for minstep"),
    if timestep_initial = 0 then error("rk_adaptive: Illegal value for timestep_initial"),
    /* Do we need to reverse some comparisons since the time we end is before the time we start at? */
    if endval >= startval then sgn:1 else sgn:-1,
    /* Make sure our first 3 arguments are lists */
    if not listp(expr) then expr:[expr],
    if not listp(vars) then vars:[vars],
    if not listp(vars_initval) then vars_initval:[vars_initval],

    /* Add the starting point to the result */
    point:vars_initval,
    result:[append([startval],vars_initval)],

    /* Now calculate the other points */
    do (
        do (
            /* Calculate the next 2 points */
            offset_1step:sgn*subst(var=time+timestep,
                subst(map("=",vars,point),expr)
            )*timestep,
            offset_2steps:offset_1step+sgn*subst(var=time+timestep*2,
                subst(map("=",vars,point+offset_1step),expr)
            )*timestep,
            /* Calculate the error. Err=1 is the limit */
            err:apply('max,
                map(
                    lambda(
                        [pnt,offs_1step,offs_2steps],
                        if cabs(pnt) > maxrelerr then
                           min(
                               cabs(2*offs_1step-offs_2steps)/maxabserr,
                               cabs((offs_1step-offs_2steps)/pnt)/maxrelerr
                           )
                        else
                            cabs(2*offs_1step-offs_2steps)/maxabserr
                    ),
                    point,offset_1step,offset_2steps
                )
            ),
            /* Save the time offset_1step is at */
            nexttime:time+timestep,
            /* See if we should adjust the time step width */
            if err>1.0 then
                timestep:sgn*max(sgn*timestep/2,sgn*minstep)
            else if err<.25 then
                timestep:sgn*min(maxstep*sgn,timestep*2),

            /* See if we are happy with the results for this point*/
            if timestep=minstep then
            (
                minstepwarn:true,
                return()
            ),
            if err<=1 then return()
        ),
        time:nexttime,
        push(append([time],point+offset_1step),result),
        point:point+offset_1step,
        if sgn*time>sgn*endval then return()
    ),
    if minstepwarn = true then warning("rk_adaptive: Didn't meet the tolerance goal."),
    /* Convert the result into a more user-friendly format (tm)*/
    args(transpose(apply('matrix,reverse(result))))
);